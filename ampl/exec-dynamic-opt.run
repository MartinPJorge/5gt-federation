reset;
option solver gurobi;
model dynamic-pricing-model.mod;
data /tmp/o.dat;

fix cpu[first(timestamps)] := 80;
fix disk[first(timestamps)] := 2000;
fix mem[first(timestamps)] := 160;
fix federation_cpu[first(timestamps)] := 480;
fix federation_disk[first(timestamps)] := 12000;
fix federation_mem[first(timestamps)] := 960;

# to DEBUG scenarios with enough local for all
## # force all to be locally deployed
## let {t in timestamps} local[t] := 1;
## fix {t in timestamps} local[t];
## 

## # force all to be federated
## let {t in timestamps} federate[t] := 1;
## fix {t in timestamps} federate[t];

## # To monitor instant rewards
## var profit {t in timestamps};
## subject to instant_profit_rule {t0 in timestamps}:
##     profit[t0] =
##     sum {i in instances, t in timestamps: t <> first(timestamps) and t<=t0 and
##             instance_arrival[i] <= prev(t) and prev(t) <= instance_departure[i]}
##         ( min(t, instance_departure[i]) - prev(t) ) / (60*60) *
##         (local[instance_arrival[i]] 
##             * (1+margin) * federate_fee[itype[i],instance_arrival[i]]
##         + federate[instance_arrival[i]] 
##             * ( (1+margin) * federate_fee[itype[i],instance_arrival[i]] 
##                 - federate_fee[itype[i],prev(t)] ) );
## 
## var instant_profit {t in timestamps};
## subject to instantaneous_rule {t in timestamps: t <> first(timestamps)}:
##     instant_profit[t] = profit[t] - profit[prev(t)];


solve;


printf "timestamp,instance,local,federate,reject\n" > /tmp/optimal-decisions.csv;
printf {i in instances} "%f,%s,%d,%d,%d\n",
    instance_arrival[i], itype[i],
    local[instance_arrival[i]],
    federate[instance_arrival[i]],
    reject[instance_arrival[i]] >> /tmp/optimal-decisions.csv;

printf "timestamp,acpu,amem,adisk,\tlocal,fed,reject,\tcpu,mem,disk,\tfcpu,fmem,fdisk\n" > /tmp/optimal-decisions-resources.csv;
printf {t in timestamps} "%f,%d,%d,%d,\t%d,%d,%d,\t%d,%d,%d,\t%d,%d,%d\n",
    t, asked_cpu[t], asked_mem[t], asked_disk[t],
    local[t], federate[t], reject[t],
    cpu[t], mem[t], disk[t],
    federation_cpu[t],
    federation_mem[t],
    federation_disk[t] >> /tmp/optimal-decisions-resources.csv;
    

# Print all variables
option display_1col 1;
display local > /tmp/optimal-solution.out;
display federate >> /tmp/optimal-solution.out;
display reject >> /tmp/optimal-solution.out;
display cpu >> /tmp/optimal-solution.out;
display mem >> /tmp/optimal-solution.out;
display disk >> /tmp/optimal-solution.out;
display federation_cpu >> /tmp/optimal-solution.out;
display federation_mem >> /tmp/optimal-solution.out;
display federation_disk >> /tmp/optimal-solution.out;
display instances >> /tmp/optimal-solution.out;
display instance_types >> /tmp/optimal-solution.out;
display timestamps >> /tmp/optimal-solution.out;
display itype >> /tmp/optimal-solution.out;
display margin >> /tmp/optimal-solution.out;
display federate_fee >> /tmp/optimal-solution.out;
display instance_arrival >> /tmp/optimal-solution.out;
display instance_departure >> /tmp/optimal-solution.out;
display asked_cpu >> /tmp/optimal-solution.out;
display asked_mem >> /tmp/optimal-solution.out;
display asked_disk >> /tmp/optimal-solution.out;
display frees_cpu >> /tmp/optimal-solution.out;
display frees_mem >> /tmp/optimal-solution.out;
display frees_disk >> /tmp/optimal-solution.out;
display frees_arrival >> /tmp/optimal-solution.out;
display dynamic_profit >> /tmp/optimal-solution.out;





